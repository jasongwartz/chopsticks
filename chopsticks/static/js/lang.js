// Generated by CoffeeScript 2.3.1
  /*
  Author: Jason Gwartz
  2016
  */
var ForLoop, IfConditional, SoundNode, Wrapper,
  indexOf = [].indexOf;

Wrapper = (function() {
  class Wrapper {
    constructor(name1, extra_html) { // TODO: create subclasses?
      this.name = name1;
      Wrapper.instances.push(this);
      this.html = `<div class="node node-wrapper panel panel-default" id="${this.name}">\n  <div class="panel-body sn-node-title">${this.name}</div>\n  ${extra_html}\n</div>`;
    }

    static parse_input(str) {
      var TypeError, i, re;
      re = /(\d+(\.\d+)?)/g; // matches all integers and floats
      // TODO: this implementation means can only schedule 5 phrases, etc
      try {
        return (function() {
          var j, len, ref, results;
          ref = str.match(re);
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            if (parseFloat(i) < 5) {
              results.push(parseFloat(i));
            }
          }
          return results;
        })();
      } catch (error1) {
        TypeError = error1;
        return [];
      }
    }

    eval_input(jq) { // parameter is the corresponding jQuery object
      return this.check(jq.find("select").val(), jq.find("input").val(), jq);
    }

  };

  // If condition, on_beats, for loop
  Wrapper.instances = [];

  return Wrapper;

}).call(this);

IfConditional = (function() {
  var extra_html, name;

  class IfConditional extends Wrapper {
    constructor() {
      super(name, extra_html);
    }

  };

  name = "If";

  extra_html = "<select class=\"form-control input-xs\" id=\"if-select\">\n    <option value=\"beat\">Beat</option>\n    <option value=\"bar\">Bar</option>\n    <option value=\"phrase\">Phrase</option>\n  </select>\n  <div class=\"sn-node-title\">is</div>\n<input type=\"text\" id=\"if-input\" class=\"form-control input-xs\">";

  return IfConditional;

}).call(this);

ForLoop = (function() {
  var extra_html, name, registered;

  // TODO: for loop not yet implemented
  class ForLoop extends Wrapper {
    constructor() {
      super(name, extra_html);
    }

    for_loop(loop_block, number_loops) {
      if (loop_block === "phrases") {
        return pass();
      } else if (loop_block === "bars") {
        return pass();
      } else if (loop_block === "beats") {
        return pass();
      }
    }

  };

  name = "For";

  registered = false;

  extra_html = "<input type=\"text\" id=\"for-input\" class=\"form-control input-xs\">\n<select class=\"form-control input-xs\" id=\"for-select\">\n    <option value=\"beat\">Beats</option>\n    <option value=\"bar\">Bars</option>\n    <option value=\"phrase\">Phrases</option>\n  </select>"; // extra html

  return ForLoop;

}).call(this);

SoundNode = (function() {
  class SoundNode {
    constructor(instrument) {
      var i, node_number;
      this.instrument = instrument;
      this.category = this.instrument.data.category;
      node_number = ((function() {
        var j, len, ref, results;
        ref = SoundNode.canvas_instances;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          if (i.instrument === this.instrument) {
            results.push(i);
          }
        }
        return results;
      }).call(this)).length + 1;
      this.id = (function() {
        switch (node_number) {
          case 1:
            return this.instrument.name;
          default:
            return this.instrument.name + node_number;
        }
      }).call(this);
      this.wrappers = {
        conditionals: {},
        forloops: {}
      };
      this.playing_phrases = [];
      this.playing_bars = [];
      this.playing_beats = [];
      this.html = `<div class="node-sample-container\n  panel panel-default" id="${this.id}-container">\n<div class="wrappers">\n</div>\n<div class="node node-sample panel-footer node-toggle" id="${this.id}">\n  <div class=" sn-node-title node-toggle">${this.id}</div>\n</div>\n</div>\n`;
    }

    phrase_eval() {
      var j, len, ref, w;
      if (!$(`#${this.id}-container`).data("live")) {
        return;
      }
      this.wrappers = [];
      this.playing_bars = [];
      this.playing_beats = [];
      ref = $(`#${this.id}-container`).find(".wrappers").children();
      for (j = 0, len = ref.length; j < len; j++) {
        w = ref[j];
        this.wrappers.push({
          wrapper: w.id.toLowerCase(),
          range: $(w).find("select").val(),
          input: Wrapper.parse_input($(w).find("input").val()),
          data: $(w).data("Wrapper"),
          live: $(w).data("live"),
          jq: $(w)
        });
      }
      return this.node_eval();
    }

    node_eval(index = 0) {
      var error;
      if (index >= this.wrappers.length) {
        this.play();
        return;
      } else if (!this.wrappers[index].live) {
        this.node_eval(index + 1);
        return;
      }
      try {
        switch (this.wrappers[index].range) {
          case "phrase" || "phrases":
            return this.eval_phrase_node(this.wrappers[index], index);
          case "bar" || "bars" || "bar":
            return this.eval_bar_node(this.wrappers[index], index);
          case "beat" || "beats":
            return this.eval_beat_node(this.wrappers[index], index);
        }
      } catch (error1) {
        error = error1;
        console.log(error);
      }
    }

    eval_bar_node(node, index, offset = 1) {
      var i, j, k, len, ref, ref1, ref2;
      switch (node.wrapper) {
        case "if":
          if (this.playing_bars.length !== 0) {
            // filter by if condition
            this.playing_bars = (function() {
              var j, len, ref, results;
              ref = this.playing_bars;
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                if (indexOf.call(node.input, i) >= 0) {
                  results.push(i);
                }
              }
              return results;
            }).call(this);
          } else {
            ref = node.input;
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              if (indexOf.call(this.playing_bars, i) < 0) {
                this.playing_bars.push(i);
              }
            }
          }
          break;
        case "for":
          for (i = k = ref1 = offset, ref2 = offset + node.input[0]; (ref1 <= ref2 ? k < ref2 : k > ref2); i = ref1 <= ref2 ? ++k : --k) {
            if (indexOf.call(this.playing_bars, i) < 0) {
              this.playing_bars.push(i);
            }
          }
      }
      // play on downbeat of phrase if no bar or beat specified
      return this.node_eval(index + 1);
    }

    eval_beat_node(node, index, start_beat = 1) {
      var bar, beat, corrected_beat, i, j, k, l, len, len1, len2, len3, len4, m, n, new_beats, o, q, r, ref, ref1, ref10, ref11, ref12, ref13, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, t;
      switch (node.wrapper) {
        case "if":
          if (this.playing_beats.length !== 0) {
            new_beats = [];
            ref = this.playing_beats;
            //@playing_beats
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              corrected_beat = (function(i) {
                // corrects for 0-base numbers in a 4-beat system
                if (i % 4 > 0) {
                  return i % 4;
                } else {
                  return 4;
                }
              })(i);
              if (ref1 = corrected_beat % 4, indexOf.call(node.input, ref1) >= 0) {
                new_beats.push(i);
              }
              // if beats already added match this node's condition
              this.playing_beats = new_beats;
            }
          } else {
            for (bar = k = 1; k <= 4; bar = ++k) {
              ref2 = node.input;
              for (l = 0, len1 = ref2.length; l < len1; l++) {
                beat = ref2[l];
                this.playing_beats.push(beat + (bar - 1) * 4);
              }
            }
          }
          break;
        // algorithm = beat + ( bar - 1 ) * 4
        case "for":
          if (this.playing_beats.length !== 0) {
            ref3 = this.playing_beats;
            for (m = 0, len2 = ref3.length; m < len2; m++) {
              start_beat = ref3[m];
              if (this.playing_bars.length !== 0) {
                ref4 = this.playing_bars;
                for (n = 0, len3 = ref4.length; n < len3; n++) {
                  bar = ref4[n];
                  for (beat = o = ref5 = start_beat, ref6 = start_beat + node.input[0]; (ref5 <= ref6 ? o < ref6 : o > ref6); beat = ref5 <= ref6 ? ++o : --o) {
                    this.playing_beats.push(beat + (bar - 1) * 4);
                  }
                }
              } else {
                for (i = q = ref7 = start_beat, ref8 = start_beat + node.input[0]; (ref7 <= ref8 ? q < ref8 : q > ref8); i = ref7 <= ref8 ? ++q : --q) {
                  this.playing_beats.push(i);
                }
              }
            }
          } else {
            // only accept first number from 'for' input
            if (this.playing_bars.length !== 0) {
              ref9 = this.playing_bars;
              for (r = 0, len4 = ref9.length; r < len4; r++) {
                bar = ref9[r];
                for (beat = s = ref10 = start_beat, ref11 = start_beat + node.input[0]; (ref10 <= ref11 ? s < ref11 : s > ref11); beat = ref10 <= ref11 ? ++s : --s) {
                  this.playing_beats.push(beat + (bar - 1) * 4);
                }
              }
            } else {
              for (i = t = ref12 = start_beat, ref13 = start_beat + node.input[0]; (ref12 <= ref13 ? t < ref13 : t > ref13); i = ref12 <= ref13 ? ++t : --t) {
                this.playing_beats.push(i);
              }
            }
          }
      }
      // only accept first number from 'for' input
      return this.node_eval(index + 1);
    }

    eval_phrase_node(node, index) {
      var i, j, k, len, ref, ref1, ref2;
      // add all input values to playing_phrases
      switch (node.wrapper) {
        case "if":
          ref = node.input;
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            if (indexOf.call(this.playing_phrases, i) < 0) {
              this.playing_phrases.push(i);
            }
          }
          break;
        case "for":
          if (!node.data.registered) {
            node.data.registered = true;
            for (i = k = ref1 = phrase, ref2 = phrase + node.input[0]; (ref1 <= ref2 ? k < ref2 : k > ref2); i = ref1 <= ref2 ? ++k : --k) {
              if (indexOf.call(this.playing_phrases, i) < 0) {
                this.playing_phrases.push(i); // add the phrase + current range
              }
            }
          }
      }
      return this.node_eval(index + 1);
    }

    play() {
      var j, k, l, len, len1, p, phrases_expired, ref, ref1, ref2, ref3, results, results1, results2;
      // check if all phrase specifications are older than current/next
      // in which case, ignore phrase markers
      // TODO: this is not fixed yet for old/now unused forloops, phrase-ifs
      phrases_expired = this.playing_phrases.every(function(i) {
        return i < phrase;
      });
      if (indexOf.call(this.playing_phrases, phrase) < 0 && this.playing_phrases.length !== 0) { // don't play this phrase

      } else {
        if (this.playing_bars.length !== 0) { // not empty list
          if (this.playing_beats.length !== 0) {
            ref = this.playing_beats;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              p = ref[j];
              if (ref1 = Math.ceil(p / 4), indexOf.call(this.playing_bars, ref1) >= 0) {
                // p // 4 gives bar num, + 1 for off-by-one offset
                results.push(this.instrument.add(p));
              } else {
                results.push(void 0);
              }
            }
            return results;
          } else {
            results1 = [];
            for (p = k = 1; k <= 16; p = k += 4) {
              if (ref2 = Math.floor(p / 4) + 1, indexOf.call(this.playing_bars, ref2) >= 0) {
                results1.push(this.instrument.add(p));
              }
            }
            return results1;
          }
        } else {
          ref3 = this.playing_beats;
          results2 = [];
          for (l = 0, len1 = ref3.length; l < len1; l++) {
            p = ref3[l];
            results2.push(this.instrument.add(p));
          }
          return results2;
        }
      }
    }

  };

  SoundNode.tray_instances = [];

  SoundNode.canvas_instances = [];

  return SoundNode;

}).call(this);
