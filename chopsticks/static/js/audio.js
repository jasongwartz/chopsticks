// Generated by CoffeeScript 2.3.1
  /*
  Author: Jason Gwartz
  2016
  */
var Instrument, JGAnalyser, LoadedSample, analyser, bar, beat, beat_increment, context, main, phrase, startPlayback, tempo,
  indexOf = [].indexOf;

// Variable declarations with global scope
context = null;

analyser = null;

phrase = 1;

beat = 0;

bar = 1;

tempo = 500.0; // milliseconds per beat - 1000 = 60bpm


// Class definitions
LoadedSample = class LoadedSample {
  // Objects of this class are playable samples which have been
  // loaded into memory and decoded (ie. are ready to be played)
  constructor(file, stretch = null) {
    var request;
    this.file = file;
    this.stretch = stretch;
    if (this.file == null) { // Uploaded sample - skip to decode
      return;
    }
    request = new XMLHttpRequest();
    request.open('GET', this.file, true);
    request.responseType = 'arraybuffer';
    request.onload = () => {
      return this.decode(request.response);
    };
    request.send();
  }

  decode(data_in) {
    return context.decodeAudioData(data_in, (decoded) => {
      return this.decoded = decoded; // @decoded is of type AudioBuffer
    }, function(e) {
      return console.log("Error loading:" + this.file + e);
    });
  }

  play(output, n) {
    var source;
    if (isNaN(n)) {
      return;
    }
    source = context.createBufferSource();
    source.buffer = this.decoded;
    source.playbackRate.value = (() => {
      if (this.stretch != null) {
        return this.decoded.duration / (tempo / 1000 * this.stretch);
      } else {
        return 1;
      }
    })();
    source.connect(output);
    source.start(n);
    return [n, source];
  }

};

Instrument = (function() {
  class Instrument {
    constructor(name, data, output) {
      this.name = name;
      this.data = data;
      if (Instrument.maxFrequency == null) {
        Instrument.computeMaxFrequency();
      }
      Instrument.instances.push(this);
      this.pattern = []; // array of beats
      this.filter = context.createBiquadFilter();
      this.filter.type = 'lowpass';
      this.filter.frequency.value = Instrument.maxFrequency;
      this.gain = context.createGain();
      this.filter.connect(this.gain);
      this.gain.connect(output);
    }

    load() {
      if (this.data.beat_stretch != null) {
        return this.sample = new LoadedSample(this.data.file, this.data.beat_stretch);
      } else {
        return this.sample = new LoadedSample(this.data.file);
      }
    }

    is_loaded() {
      return this.sample.decoded != null; // Check if not undefined/null
    }

    add(b) { // playSound
      this.pattern.sort(function(a, b) {
        return a - b;
      });
      if (indexOf.call(this.pattern, b) < 0) {
        return this.pattern.push(b);
      }
    }

    // beat 1 - 16
    play(time) {
      var i, j, len, ref, results;
      ref = this.pattern;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        results.push((() => {
          var b;
          b = (i - 1) * tempo / 1000 + time;
          if ((this.previous_buffer != null) && (this.previous_buffer[0] + this.sample.decoded.duration >= b)) {
            // milliseconds to seconds conversion, account for off by one

            // There was a bug here when samples cross a phrase (edge-case with
            //   two different nodes for the same sample), can't replicate anymore
            //   but not certain it's fixed
            this.previous_buffer[1].stop(b);
          }
          return this.previous_buffer = this.sample.play(this.filter, b);
        })());
      }
      return results;
    }

    tryout(time) {
      return this.sample.play(this.filter, time);
    }

    static reset() {
      var i, j, len, ref, results;
      ref = Instrument.instances;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        results.push(i.pattern = []);
      }
      return results;
    }

    static computeMaxFrequency() {
      return Instrument.maxFrequency = context.sampleRate / 2;
    }

    static compute_filter(rate) {
      var minValue, mult, numberOfOctaves;
      
      // Source: http://www.html5rocks.com/en/tutorials/
      // webaudio/intro/js/filter-sample.js
      minValue = 40;
      //// Logarithm (base 2) to compute how many octaves fall in the range.
      numberOfOctaves = Math.log(Instrument.maxFrequency / minValue) / Math.LN2;
      //// Compute a multiplier from 0 to 1 based on an exponential scale.
      mult = Math.pow(2, numberOfOctaves * (rate - 1.0));
      //// Get back to the frequency value between min and max.
      return Instrument.maxFrequency * mult;
    }

  };

  Instrument.instances = [];

  Instrument.maxFrequency = null;

  return Instrument;

}).call(this);

JGAnalyser = class JGAnalyser {
  constructor() {
    this.draw = this.draw.bind(this);
    this.node = context.createAnalyser();
    this.node.fftSize = 2048;
    this.bufferLength = this.node.fftSize;
    this.dataArray = new Uint8Array(this.bufferLength);
    //  https://github.com/mdn/voice-change-o-matic/blob/gh-pages/scripts/app.js#L123-L167
    this.canvas = document.getElementById("visual");
    this.HEIGHT = 30;
    this.WIDTH = $(this.canvas).parent().width();
    this.canvas.width = this.WIDTH;
    this.canvas.height = this.HEIGHT;
    this.canvasCtx = this.canvas.getContext("2d");
    this.canvasCtx.clearRect(0, 0, this.WIDTH, this.HEIGHT);
  }

  set_black() {
    return this.canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
  }

  set_red() {
    return this.canvasCtx.strokeStyle = 'rgb(255, 0, 0)';
  }

  draw() {
    var drawVisual, i, j, phrase_beat, ref, sliceWidth, v, x, y;
    // Reset width
    this.WIDTH = $(this.canvas).parent().width();
    
    // TODO: fix bug where auto-resizing canvas breaks the colours
    //@canvas.width = @WIDTH
    // TODO: Make colours constants or something other than hard-coded
    this.canvasCtx.fillStyle = 'rgb(122, 188, 252)';
    drawVisual = requestAnimationFrame(this.draw);
    this.node.getByteTimeDomainData(this.dataArray);
    this.canvasCtx.fillRect(0, 0, this.WIDTH, this.HEIGHT);
    this.canvasCtx.lineWidth = 2;
    this.canvasCtx.beginPath();
    sliceWidth = this.WIDTH * 1.0 / this.bufferLength;
    x = 0;
    // Calculate percentage through the bar to portion the animation
    phrase_beat = (function() {
      var b;
      b = beat + (bar - 1) * 4;
      if (b) {
        return b;
      } else {
        return 16;
      }
    })();
    for (i = j = 0, ref = this.bufferLength; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      v = this.dataArray[i] / 128.0;
      y = v * this.HEIGHT / 2;
      if (i === 0) {
        this.canvasCtx.moveTo(x, y);
      } else {
        this.canvasCtx.lineTo(x, y);
      }
      x += sliceWidth;
      // Only draw percentage of animation to denote progress through phrase
      if (x / this.WIDTH >= phrase_beat / 16) {
        break;
      }
    }
    this.canvasCtx.lineTo(this.canvas.width, this.canvas.height / 2);
    return this.canvasCtx.stroke();
  }

};

// Core utility function definitions
startPlayback = function() {
  var debug_starttime, instrument, j, k, len, len1, ref, ref1, s;
  debug_starttime = context.currentTime;
  Instrument.reset();
  ref = SoundNode.canvas_instances;
  for (j = 0, len = ref.length; j < len; j++) {
    s = ref[j];
    s.phrase_eval();
  }
  ref1 = Instrument.instances;
  for (k = 0, len1 = ref1.length; k < len1; k++) {
    instrument = ref1[k];
    instrument.play(context.currentTime);
  }
  // this may be unnecessarily iterating over all instruments, not just live

  // start loop to keep beat labels in UI up to date
  beat_increment();
  
  // change analyser colour back to black
  analyser.set_black();
  // Set dispatch to change colour to red to indicate refreshing
  setTimeout(function() {
    return analyser.set_red();
  }, tempo * 16 - tempo * 2);
  // Timer to keep in loop
  setTimeout(function() {
    // Log the diff against when the callback was expected to occur
    console.log("Variance on expected was: " + (((debug_starttime + (tempo * 16 / 1000)) - context.currentTime) * 1000) + " milliseconds.");
    return startPlayback();
  }, tempo * 16);
  
  // Log the time to compute the scheduler function
  return console.log("Computation was: " + ((context.currentTime - debug_starttime) * 1000) + " milliseconds.");
};

beat_increment = function() {
  // only set time-out within a bar
  // the auto-reload of the phrase will trigger the call
  beat += 1;
  update_beat_labels();
  switch (false) {
    case !(bar === 4 && beat === 4):
      beat = 0;
      bar = 1;
      return phrase += 1;
    case !(bar !== 4 && beat === 4):
      beat = 0;
      bar += 1;
      return setTimeout(function() { // TODO: async bug here, might be from tab switching
        return beat_increment();
      }, tempo); // in the middle of a bar
    default:
      return setTimeout(function() {
        return beat_increment();
      }, tempo);
  }
};

// Preloader function definitions
main = function() {
  var final_gain, output_chain;
  window.AudioContext = window.AudioContext || window.webkitAudioContext;
  context = new AudioContext();
  // sources go into output_chain for "master" manipulation
  output_chain = context.createGain();
  // after all "master" controls, final_gain goes to output
  final_gain = context.createGain();
  
  // initiate the analyser
  analyser = new JGAnalyser();
  analyser.draw();
  // Wire up the components
  output_chain.connect(analyser.node);
  analyser.node.connect(final_gain);
  final_gain.connect(context.destination);
  // async load sample data from JSON
  return $.getJSON("static/sampledata.json", function(result) {
    var d, i, init_samples, j, k, len, len1, ref, ref1, sample_data, v;
    sample_data = result;
    for (d in sample_data) {
      v = sample_data[d];
      // Init all the Instrument and SoundNode objects
      new Instrument(d, v, output_chain);
    }
    ref = Instrument.instances;
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      i.load();
    }
    ref1 = Instrument.instances;
    // calls into lang.coffee
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      i = ref1[k];
      SoundNode.tray_instances.push(new SoundNode(i));
    }
    ui_init(); // Initialise the button listeners
    
    // TODO: BUG Safari only: first page load doesn't start playing automatically
    // closer to fixing it using this indented callback but not quite
    init_samples = function() {
      var l, len2, ready, ref2;
      ready = true;
      ref2 = Instrument.instances;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        i = ref2[l];
        if (!i.is_loaded()) {
          ready = false;
        }
      }
      if (!ready) {
        $('#samples-loading').modal('show');
        console.log("Still loading: " + ((function() {
          var len3, m, ref3, results;
          ref3 = Instrument.instances;
          results = [];
          for (m = 0, len3 = ref3.length; m < len3; m++) {
            i = ref3[m];
            if (!i.is_loaded()) {
              results.push(" " + i.name);
            }
          }
          return results;
        })()));
        return setTimeout(init_samples, 1000);
      } else {
        console.log("All samples loaded.");
        return $('#samples-loading').modal('hide');
      }
    };
    return init_samples();
  });
};
